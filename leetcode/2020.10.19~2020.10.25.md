# 2020.10.19~2020.10.25

## Andrewsher
### 179 最大数
题目描述：

给定一组非负整数 nums，重新排列它们每位数字的顺序使之组成一个最大的整数。

注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。
``` C++
#include <string>
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    string largestNumber(vector<int>& nums) {
		if(nums.empty())
		{
			return "";
		}
		if(nums.size() == 1)
		{
			return to_string(nums[0]);
		}
		string res = "";
		sort(nums.begin(), nums.end(), comparison);
		for(int n: nums)
		{
			res += to_string(n);
		}
		if(res[0] == '0')
		{
			return "0";
		}
		return res;
    }
    static bool comparison(int a, int b)
    {
    	string a_string = to_string(a);
    	string b_string = to_string(b);
    	return a_string + b_string > b_string + a_string;
	}
};

int main()
{
	Solution* S = new Solution();
	vector<int> nums{3, 30, 34, 5, 9};
	cout << S->largestNumber(nums) << endl;
	return 0;
}
```
### 73. 矩阵置零

题目描述：给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。

``` C++
#include <iostream>
#include <vector>
using namespace std;
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        if(matrix.size() == 0 || matrix[0].size() == 0) {
            return;
        }
        bool firstRow = false, firstCol = false;
        for(int i = 0; i < matrix.size(); i++) {
            if(matrix[i][0] == 0) {
                firstRow = true;
            }
        }
        for(int j = 0; j < matrix[0].size(); j++) {
            if(matrix[0][j] == 0) {
                firstCol = true;
            }
        }
        for(int i = 1; i < matrix.size(); i++) {
            for(int j = 1; j < matrix[0].size(); j++) {
                if(matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        for(int i = 1; i < matrix.size(); i++) {
            for(int j = 1; j < matrix[0].size(); j++) {
                if(matrix[i][0] == 0) {
                    for(int k = 1; k < matrix[i].size(); k++) matrix[i][k] = 0;
                }
                if(matrix[0][j] == 0) {
                    for(int k = 1; k < matrix.size(); k++) matrix[k][j] = 0;
                }
            }
        }
        if(firstRow) {
            for(int i = 0; i < matrix.size(); i++) matrix[i][0] = 0;
        }
        if(firstCol) {
            for(int j = 0; j < matrix[0].size(); j++) matrix[0][j] = 0;
        }
        return;
    }
};

int main() {
    vector<vector<int> > matrix = {{0,1,2,0}, {3,4,5,2}, {1,3,1,5}};
    Solution S;
    S.setZeroes(matrix);
    for(int i = 0; i < matrix.size(); i++) {
        for(int j = 0; j < matrix[0].size(); j++) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
}
```

### 74. 搜索二维矩阵
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

* 每行中的整数从左到右按升序排列。
* 每行的第一个整数大于前一行的最后一个整数。

``` C++
#include <iostream>
#include <vector>
using namespace std;
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.size() == 0 || matrix[0].size() == 0) return false;
        int i = 0, j = matrix[0].size() - 1;
        while(i < matrix.size() && j >= 0) {
            if(matrix[i][j] < target) {
                i++;
            }
            else if(matrix[i][j] == target) {
                return true;
            }
            else if(matrix[i][j] > target) {
                j--;
            }
        }
        return false;
    }
};

int main() {
    vector<vector<int> > matrix = {{1,3,5,7}, {10,11,16,20}, {23,30,34,50}};
    Solution S;
    cout << S.searchMatrix(matrix, 3);
    return 0;
}
```

### 77. 组合

题目描述：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

``` C++
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    vector<vector<int>> res;
    vector<int> tmp;
    vector<vector<int>> combine(int n, int k) {
        dfs(n, k, 1);
        return res;
    }
private:
    void dfs(int n, int k, int start) {
        /* 从start到n选择k个数字，存储在tmp里面 */
        /* 如果tmp里面已经有k个数字，则将tmp压入res */
        /* 如果start到n凑不出k个数字，则直接返回 */
        if(n - start + 1 < k) return;
        else if(k == 0) {
            res.push_back(tmp);
            return;
        }
        else if(k < 0) {
            return;
        }
        tmp.push_back(start);
        dfs(n, k - 1, start + 1);
        tmp.pop_back();
        dfs(n, k, start + 1);
    }
};

int main() {
    vector<vector<int>> res;
    Solution S;
    res = S.combine(4, 2);
    for(int i = 0; i < res.size(); i++) {
        for(int j = 0; j < res[0].size(); j++) {
            cout << res[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

### 451. 根据字符出现频率排序

给定一个字符串，请将字符串里的字符按照出现的频率降序排列

``` C++
#include <iostream>
#include <vector>
#include <string>
#include <map>
using namespace std;

class Solution {
private:
    map<char, int> count;
public:
    string frequencySort(string s) {
        for(int i = 0; i < s.length(); i++) {
            if(count.find(s[i]) != count.end()) {
                count[s[i]] = count[s[i]] + 1;
            }
            else {
                count[s[i]] = 1;
            }
        }
        vector<vector<char>> * tmp = new vector<vector<char>>;
        for(int i = 0; i <= s.length(); i++) {
            tmp->push_back({});
        }

        for(auto iter = count.begin(); iter != count.end(); iter++) {
            tmp->at(iter->second).push_back(iter->first);
        }

        string res;
        for(int times = tmp->size() - 1; times >= 0; times--) {
            if(tmp->at(times).size() == 0) continue;
            for(int j = 0; j < tmp->at(times).size(); j++) {
                for(int t = 0; t < times; t++) {
                    res += tmp->at(times)[j];
                }
                
            }
        }
        return res;
    }
};

int main() {
    Solution S;
    cout << S.frequencySort("eeee") << endl;
    return 0;
}
```
## Kayden

### 179 最大数

- 题目描述：
  - 给定一组非负整数 nums，重新排列它们每位数字的顺序使之组成一个最大的整数。
  - 注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。
- 题解：主要是对内部元素的排序，即a和b的大小问题：ab>ba则说明a>b
- python2可以自定义cmp函数，python3则需要其他方法
  
```Python
import functools
def compareFunc(a, b):
    if a+b > b+a:
        return -1
    elif a+b == b+a:
        return 0
    else:
        return 1

class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        ans = ''.join(sorted(map(str, nums), key=functools.cmp_to_key(compareFunc)))
        return '0' if ans[0]=='0' else ans
```

```python
class Cmp(str):
    def __lt__(a, b):
        return a+b > b+a

class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        ans = ''.join(sorted(map(str, nums), key=Cmp))
        return '0' if ans[0]=='0' else ans
```

```C++

```

## Dawn
